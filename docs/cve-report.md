# CVE Scanning & Remediation Report

## Scanning Tool

[Trivy](https://github.com/aquasecurity/trivy) is used for container image vulnerability scanning.

```bash
# Scan each image
trivy image cthomaspdx1/swish-python3:latest
trivy image cthomaspdx1/swish-python2:latest
trivy image cthomaspdx1/swish-r:latest
```

## Expected Findings

### Python 3 Image (`swish-python3`)
- **Base OS (Debian slim):** Moderate number of CVEs in system libraries (glibc, openssl, etc.)
- **Python packages:** Generally low â€” numpy, pandas, scipy are well-maintained
- **Severity:** Mostly LOW/MEDIUM from OS packages

### Python 2 Image (`swish-python2`)
- **Critical risk:** Python 2.7 is EOL (since Jan 2020) and no longer receives security patches
- **Base OS:** Older Debian version with more unpatched CVEs
- **Python packages:** Pinned to older versions (e.g., pyspark 2.4.8) with known vulnerabilities
- **Severity:** Expected HIGH/CRITICAL findings

### R Image (`swish-r`)
- **Base OS (Debian):** Similar OS-level CVEs as Python images
- **R packages:** tidyverse pulls in many compiled dependencies with potential CVEs
- **Severity:** Mostly LOW/MEDIUM

## Remediation Strategies

### 1. Update Base Images Regularly
- Pin base images to specific versions and update monthly
- Use `python:3.12-slim` over `python:3.12` to reduce attack surface

### 2. Pin Package Versions
- Lock all dependency versions in requirements files
- Use `pip freeze` / `renv` to generate lockfiles for reproducible, auditable builds

### 3. Remove Unnecessary Packages
- Purge build tools (gcc, g++) after compilation
- Remove apt caches and temp files in the same layer

### 4. Address Python 2 EOL
- Migrate Python 2 workloads to Python 3 where possible
- If Python 2 is required, accept the risk and isolate the workload with network policies

### 5. Automated Scanning in CI/CD
- Trivy runs on every push via GitHub Actions
- `exit-code: 0` currently allows builds with vulnerabilities (for visibility)
- Can be changed to `exit-code: 1` to fail builds on CRITICAL/HIGH findings

## Avoiding Malicious Packages

### Hash Verification
- Use `pip install --require-hashes` with a lockfile containing SHA256 hashes
- Ensures downloaded packages match expected content

### Private Registry / Mirror
- Host an internal PyPI mirror (e.g., Artifactory, Nexus) with vetted packages
- Configure pip to only install from the internal mirror

### Allow-Lists
- Maintain a curated list of approved packages
- CI/CD checks that only approved packages are in requirements files

### Dependency Review
- Use tools like `pip-audit` or `safety` to check for known vulnerabilities
- Review new dependencies before adding them to requirements files
